#Hash与Hash碰撞

- - -

*Hash*，简单来讲，是一种将任意长度的输入变换成固定长度的输出，固定长度的输出在“实际应用场景”下可以代表该输入。Hash函数通常被翻译成散列函数。Hash通常用来校验信息的一致性。

Hash函数的实现多种多样，在安全领域应用最为广泛的是SHA-x系列和MDx系列。Hash函数也划分为带密钥的Hash函数和不带密钥的Hash函数，通常所说的Hash函数是不带密钥的Hash函数。

由于Hash固定长度输出的特性，必然会存在多个不同输入产生相同输出的情况。如果两个输入串的hash函数的值一样，则称这两个串是一个碰撞(Collision)。在理论范围内，存在一个输出串对应无穷多个输入串，所以碰撞具有其必然性。

如果找到碰撞，那么意味着我们可以破坏信息的一致性而不被接收方察觉，搜寻指定输入的Hash碰撞值的过程被称作“Hash破解”。这里需要说明的是，Hash函数必须是不可逆的，所以不存在从散列值到原始输入的破解（这里不包括暴力破解，使用彩虹表是暴力破解的最佳方式，但是仍然无法保证破解到的数据是原始数据）.
###Hash碰撞的拒绝式服务攻击
有恶意的人会通过这个安全弱点会让你的服务器运行巨慢无比。这个安全弱点利用了各语言的Hash算法的“非随机性”可以制造出N多的value不一样，但是key一样数据，然后让你的Hash表成为一张单向链表，而导致你的整个网站或是程序的运行性能以级数下降（可以很轻松的让你的CPU升到100%）。
**举个例子:**
我可以给你后台提交一个有10K字段的表单，这些字段名都被我精心地设计过，他们全是Hash Collision ，于是你的Web Server或语言处理这个表单的时候，就会建造这个hash map，于是在每插入一个表单字段的时候，都会先遍历一遍你所有已插入的字段，于是你的服务器的CPU一下就100%了，你会觉得这10K没什么，那么我就发很多个的请求，你的服务器一下就不行了。

要防守这样的攻击，有下面几个招：

▲ 打补丁，把hash算法改了。

▲ 限制POST的参数个数，限制POST的请求长度。

▲ 最好还有防火墙检测异常的请求。

不过，对于更底层的或是其它形式的攻击，可能就有点麻烦了。

###解决方法(了解)
1.开放地址法
2.线性探测法
3.链地址法（拉链法）
4.二次探测法
5.伪随机探测法
6.再散列（双重散列，多重散列）
7.建立一个公共溢出区